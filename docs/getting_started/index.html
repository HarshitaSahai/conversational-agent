



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="Plato Research dialogue System">
      
      
        <link rel="canonical" href="https://uber-research.github.io/plato-research-dialogue-system/getting_started/">
      
      
        <meta name="author" content="Alexandros Papangelis">
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../favicon.ico">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.0">
    
    
      
        <title>Getting Started - Plato RDS</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.0284f74d.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-palette.01803549.css">
      
      
        
        
        <meta name="theme-color" content="#2196f3">
      
    
    
      <script src="../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    
      <link rel="stylesheet" href="../stylesheets/extra.css">
    
      <link rel="stylesheet" href="../stylesheets/manni.css">
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="blue" data-md-color-accent="blue">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#installation" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
    <nav class="md-header-nav md-grid">
        <div class="md-flex">
            <div class="md-flex__cell md-flex__cell--shrink">
                <a class="md-header-nav__button md-logo"
                   href="https://uber-research.github.io/plato-research-dialogue-system/" title="Plato RDS">
                    <img src="../images/plato_grey.svg" style="height:1.2rem;">
                </a>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
                <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch">
                <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
                    
                    <span class="md-header-nav__topic">
                    Getting Started
                    </span>
                    
                </div>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
                
                
                <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
                
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
                
                
            </div>
            
            <div class="md-flex__cell md-flex__cell--shrink">
                <div class="md-header-nav__source">
                    


  

<a href="https://github.com/uber-research/plato-research-dialogue-system/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    uber-research/plato-research-dialogue-system
  </div>
</a>
                </div>
            </div>
            
        </div>
    </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
    <label class="md-nav__title md-nav__title--site" for="__drawer">
        <a class="md-nav__button md-logo" href="https://uber-research.github.io/plato-research-dialogue-system/"
           title="Plato RDS">
            <img src="../images/plato_grey.svg" style="width: 10rem">
        </a>
    </label>
    
    <div class="md-nav__source">
        


  

<a href="https://github.com/uber-research/plato-research-dialogue-system/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    uber-research/plato-research-dialogue-system
  </div>
</a>
    </div>
    
    <ul class="md-nav__list" data-md-scrollfix>
        
        
        
        


  <li class="md-nav__item">
    <a href=".." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

        
        
        
        


  <li class="md-nav__item">
    <a href="../about/" title="About" class="md-nav__link">
      About
    </a>
  </li>

        
        
        
        

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Getting Started
      </label>
    
    <a href="./" title="Getting Started" class="md-nav__link md-nav__link--active">
      Getting Started
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#installation" title="Installation" class="md-nav__link">
    Installation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#installing-plato-from-source-code-recommended" title="Installing Plato from source code (Recommended)" class="md-nav__link">
    Installing Plato from source code (Recommended)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#common-issues-during-installation" title="Common Issues During Installation" class="md-nav__link">
    Common Issues During Installation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#running-plato" title="Running Plato" class="md-nav__link">
    Running Plato
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#building-a-conversational-agent-with-plato" title="Building a Conversational Agent with Plato" class="md-nav__link">
    Building a Conversational Agent with Plato
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#domain" title="Domain" class="md-nav__link">
    Domain
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#controller" title="Controller" class="md-nav__link">
    Controller
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agent" title="Agent" class="md-nav__link">
    Agent
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rule-based-modules" title="Rule-based modules" class="md-nav__link">
    Rule-based modules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trained-modules" title="Trained modules" class="md-nav__link">
    Trained modules
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#plato-internal-experience" title="Plato internal experience" class="md-nav__link">
    Plato internal experience
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parsing-data-with-plato" title="Parsing data with Plato" class="md-nav__link">
    Parsing data with Plato
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#training-components-of-conversational-agents" title="Training Components of Conversational Agents" class="md-nav__link">
    Training Components of Conversational Agents
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#train-nlu" title="Train NLU" class="md-nav__link">
    Train NLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train-dst" title="Train DST" class="md-nav__link">
    Train DST
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train-dialogue-policy" title="Train Dialogue Policy" class="md-nav__link">
    Train Dialogue Policy
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#supervised-dialogue-policy" title="Supervised Dialogue Policy" class="md-nav__link">
    Supervised Dialogue Policy
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reinforce-dialogue-policy" title="Reinforce Dialogue Policy" class="md-nav__link">
    Reinforce Dialogue Policy
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train-nlg" title="Train NLG" class="md-nav__link">
    Train NLG
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train-an-end-to-end-conversational-agent-based-on-seq2seq" title="Train an end-to-end conversational agent based on Seq2Seq" class="md-nav__link">
    Train an end-to-end conversational agent based on Seq2Seq
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-write-a-metalwoz-data-parser-that-reads-the-data-and-procudes-csv-files" title="1. Write a MetalWOZ data parser that reads the data and procudes CSV files" class="md-nav__link">
    1. Write a MetalWOZ data parser that reads the data and procudes CSV files
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-write-a-config-for-plato-parse" title="2. Write a config for plato parse" class="md-nav__link">
    2. Write a config for plato parse
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-train-an-end-to-end-model" title="3. Train an end-to-end model" class="md-nav__link">
    3. Train an end-to-end model
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-write-a-class-inheriting-from-conversational-module-that-loads-and-queries-the-model" title="4. Write a class inheriting from Conversational Module that loads and queries the model" class="md-nav__link">
    4. Write a class inheriting from Conversational Module that loads and queries the model
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-write-a-plato-generic-yaml-config-and-run-your-agent" title="5. Write a Plato generic yaml config and run your agent!" class="md-nav__link">
    5. Write a Plato generic yaml config and run your agent!
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#training-multiple-conversational-agents-simultaneously" title="Training Multiple Conversational Agents Simultaneously" class="md-nav__link">
    Training Multiple Conversational Agents Simultaneously
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#user-simulators" title="User Simulators" class="md-nav__link">
    User Simulators
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#agenda-based-user-simulator" title="Agenda-Based User Simulator" class="md-nav__link">
    Agenda-Based User Simulator
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dialogue-act-to-language-user-simulator" title="Dialogue Act to Language User Simulator" class="md-nav__link">
    Dialogue Act to Language User Simulator
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-a-new-module" title="Create a new module" class="md-nav__link">
    Create a new module
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create-new-states-actions-learning-algorithms-and-more" title="Create new States, Actions, Learning Algorithms, and more" class="md-nav__link">
    Create new States, Actions, Learning Algorithms, and more
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#graphical-user-interface" title="Graphical User Interface" class="md-nav__link">
    Graphical User Interface
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#upcoming-tutorials" title="Upcoming Tutorials" class="md-nav__link">
    Upcoming Tutorials
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#upcoming-features" title="Upcoming Features" class="md-nav__link">
    Upcoming Features
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
    </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#installation" title="Installation" class="md-nav__link">
    Installation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#installing-plato-from-source-code-recommended" title="Installing Plato from source code (Recommended)" class="md-nav__link">
    Installing Plato from source code (Recommended)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#common-issues-during-installation" title="Common Issues During Installation" class="md-nav__link">
    Common Issues During Installation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#running-plato" title="Running Plato" class="md-nav__link">
    Running Plato
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#building-a-conversational-agent-with-plato" title="Building a Conversational Agent with Plato" class="md-nav__link">
    Building a Conversational Agent with Plato
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#domain" title="Domain" class="md-nav__link">
    Domain
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#controller" title="Controller" class="md-nav__link">
    Controller
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#agent" title="Agent" class="md-nav__link">
    Agent
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rule-based-modules" title="Rule-based modules" class="md-nav__link">
    Rule-based modules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trained-modules" title="Trained modules" class="md-nav__link">
    Trained modules
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#plato-internal-experience" title="Plato internal experience" class="md-nav__link">
    Plato internal experience
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parsing-data-with-plato" title="Parsing data with Plato" class="md-nav__link">
    Parsing data with Plato
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#training-components-of-conversational-agents" title="Training Components of Conversational Agents" class="md-nav__link">
    Training Components of Conversational Agents
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#train-nlu" title="Train NLU" class="md-nav__link">
    Train NLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train-dst" title="Train DST" class="md-nav__link">
    Train DST
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train-dialogue-policy" title="Train Dialogue Policy" class="md-nav__link">
    Train Dialogue Policy
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#supervised-dialogue-policy" title="Supervised Dialogue Policy" class="md-nav__link">
    Supervised Dialogue Policy
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reinforce-dialogue-policy" title="Reinforce Dialogue Policy" class="md-nav__link">
    Reinforce Dialogue Policy
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train-nlg" title="Train NLG" class="md-nav__link">
    Train NLG
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train-an-end-to-end-conversational-agent-based-on-seq2seq" title="Train an end-to-end conversational agent based on Seq2Seq" class="md-nav__link">
    Train an end-to-end conversational agent based on Seq2Seq
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-write-a-metalwoz-data-parser-that-reads-the-data-and-procudes-csv-files" title="1. Write a MetalWOZ data parser that reads the data and procudes CSV files" class="md-nav__link">
    1. Write a MetalWOZ data parser that reads the data and procudes CSV files
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-write-a-config-for-plato-parse" title="2. Write a config for plato parse" class="md-nav__link">
    2. Write a config for plato parse
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-train-an-end-to-end-model" title="3. Train an end-to-end model" class="md-nav__link">
    3. Train an end-to-end model
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-write-a-class-inheriting-from-conversational-module-that-loads-and-queries-the-model" title="4. Write a class inheriting from Conversational Module that loads and queries the model" class="md-nav__link">
    4. Write a class inheriting from Conversational Module that loads and queries the model
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5-write-a-plato-generic-yaml-config-and-run-your-agent" title="5. Write a Plato generic yaml config and run your agent!" class="md-nav__link">
    5. Write a Plato generic yaml config and run your agent!
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#training-multiple-conversational-agents-simultaneously" title="Training Multiple Conversational Agents Simultaneously" class="md-nav__link">
    Training Multiple Conversational Agents Simultaneously
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#user-simulators" title="User Simulators" class="md-nav__link">
    User Simulators
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#agenda-based-user-simulator" title="Agenda-Based User Simulator" class="md-nav__link">
    Agenda-Based User Simulator
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dialogue-act-to-language-user-simulator" title="Dialogue Act to Language User Simulator" class="md-nav__link">
    Dialogue Act to Language User Simulator
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#create-a-new-module" title="Create a new module" class="md-nav__link">
    Create a new module
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#create-new-states-actions-learning-algorithms-and-more" title="Create new States, Actions, Learning Algorithms, and more" class="md-nav__link">
    Create new States, Actions, Learning Algorithms, and more
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#graphical-user-interface" title="Graphical User Interface" class="md-nav__link">
    Graphical User Interface
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#upcoming-tutorials" title="Upcoming Tutorials" class="md-nav__link">
    Upcoming Tutorials
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#upcoming-features" title="Upcoming Features" class="md-nav__link">
    Upcoming Features
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/uber-research/plato-research-dialogue-system/edit/master/mkdocs/docs/getting_started.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                  <h1>Getting Started</h1>
                
                <h2 id="installation">Installation<a class="headerlink" href="#installation" title="Permanent link">&para;</a></h2>
<p>First make sure you have python version 3.6 or higher installed on your machine. Next
you need to clone the Plato repository:</p>
<div class="codehilite"><pre><span></span>git clone git@github.com:uber-research/plato-research-dialogue-system.git
</pre></div>


<p>Next you need to install some pre-requisites:</p>
<ul>
<li>
<p>For MacOS:</p>
<ul>
<li><code>brew install portaudio</code></li>
<li><code>brew install gmp</code> </li>
<li><code>pip install pyaudio</code></li>
</ul>
</li>
<li>
<p>For Ubuntu/Debian:
    <code>sudo apt-get install python3-pyaudio</code></p>
</li>
<li>
<p>For Windows: Nothing is needed to be pre-installed</p>
</li>
</ul>
<p>Next step is installing Plato. To install Plato you should directly install it from 
source code.</p>
<h3 id="installing-plato-from-source-code-recommended">Installing Plato from source code (Recommended)<a class="headerlink" href="#installing-plato-from-source-code-recommended" title="Permanent link">&para;</a></h3>
<p>Installing Plato from source code allows installation in editable mode which means that
if you make changes to the source code, it will directly effect execution. </p>
<ol>
<li>
<p>Navigate to the directory of Plato (where you cloned the plato repository in the previous
step).</p>
</li>
<li>
<p>We recommend to create a new python environment. To set up the new python environment:</p>
</li>
</ol>
<p>2.1 install virtualenv</p>
<p><code>sudo pip install virtualenv</code></p>
<p>2.2 create a new python environment:</p>
<p><code>python3 -m venv &lt;/path/to/new/virtual/environment&gt;</code></p>
<p>2.3 activate the new python environment:</p>
<p><code>source &lt;/path/to/new/virtual/environment/bin&gt;/bin/activate</code></p>
<ol>
<li>
<p>Install Plato:</p>
<p><code>pip install -e .</code></p>
</li>
</ol>
<p>To support speech it is necessary to install <a href="https://pypi.org/project/PyAudio/">PyAudio</a>, 
which has a number of dependencies that might not exist on a developer's 
machine. If the steps above are unsuccessful, this <a href="https://stackoverflow.com/questions/5921947/pyaudio-installation-error-command-gcc-failed-with-exit-status-1">post</a> 
on a PyAudio installation error includes instructions on how to get these 
dependencies and install PyAudio. </p>
<h3 id="common-issues-during-installation">Common Issues During Installation<a class="headerlink" href="#common-issues-during-installation" title="Permanent link">&para;</a></h3>
<p><code>CommonIssues.md</code> file contains common issues and their resolution that a user 
might encounter while installation.</p>
<h2 id="running-plato">Running Plato<a class="headerlink" href="#running-plato" title="Permanent link">&para;</a></h2>
<p>To run Plato after installation, you can simply run the <code>plato</code> command in the terminal.
The <code>plato</code> command receives 4 sub-commands:
* <code>run</code>
* <code>gui</code>
* <code>domain</code>
* <code>parse</code></p>
<p>Each of these sub-commands receives a value for the <code>--config</code> argument that points to
a configuration file. We will describe these configuration files in detail later in the 
document but remember that <code>plato run --config</code> and <code>plato gui --config</code> receive
 an application configuration file 
(examples could be found here: <code>plato/example/config/application/</code>),
<code>plato domain --config</code> receives a domain configuration (examples could be found here: 
<code>plato/example/config/domain/</code>), and <code>plato parse --config</code> receives a parser configuration
file (examples could be found here: <code>plato/example/config/parser/</code>).</p>
<p>For the value that is passed to <code>--config</code> Plato first checks to see if the value 
is the address of a file on the machine. If it is, then Plato tries to parse that file. 
If it is not, Plato checks to see if the value is a name of a file within the 
<code>plato/example/config/&lt;application, domain, or parser&gt;</code> directory. </p>
<p>For some quick examples, try the following configuration files for the Cambridge
Restaurants domain:</p>
<div class="codehilite"><pre><span></span>plato run --config CamRest_user_simulator.yaml
</pre></div>


<div class="codehilite"><pre><span></span>plato run --config CamRest_text.yaml
</pre></div>


<div class="codehilite"><pre><span></span>plato run --config CamRest_speech.yaml
</pre></div>


<h2 id="building-a-conversational-agent-with-plato">Building a Conversational Agent with Plato<a class="headerlink" href="#building-a-conversational-agent-with-plato" title="Permanent link">&para;</a></h2>
<p>An application, i.e. conversational system, in Plato contains three major parts:</p>
<ul>
<li>Domain</li>
<li>Controller</li>
<li>Agent</li>
</ul>
<p>These parts are declared in an application configuration file. Examples of 
such configuration files could be found at <code>plato/example/config/application/</code>
In the rest of this section we describe each of these parts in details.</p>
<h3 id="domain">Domain<a class="headerlink" href="#domain" title="Permanent link">&para;</a></h3>
<p>For implementing a task-oriented dialog system in Plato the user needs to specify two
components that constitute the <em>domain</em> of the dialog system:
* Ontology 
* Database</p>
<p>Plato provides a command for automating this process of building the ontology and database.
Let's say for example that you want to build a conversational agent for a 
flower shop, and you have the following items in a .csv (this file could be found at
<code>plato/example/data/flowershop.csv</code>):</p>
<div class="codehilite"><pre><span></span>id,type,color,price,occasion
1,rose,red,cheap,any
2,rose,white,cheap,anniversary
3,rose,yellow,cheap,celebration
4,lilly,white,moderate,any
5,orchid,pink,expensive,any
6,dahlia,blue,expensive,any
</pre></div>


<p>To automatically generate a .db SQL file 
and a .json Ontology file you need to create a domain configuration file within which 
you should specify the path to the csv file, output paths, as well as informable, 
requestable, and system-requestable slots:
(e.g. <code>plato/example/config/domain/create_flowershop_domain.yaml</code>):</p>
<div class="codehilite"><pre><span></span><span class="n">GENERAL</span><span class="o">:</span>
  <span class="n">csv_file_name</span><span class="o">:</span> <span class="n">plato</span><span class="sr">/example/data/</span><span class="n">flowershop</span><span class="o">.</span><span class="na">csv</span>
  <span class="n">db_table_name</span><span class="o">:</span> <span class="n">flowershop</span>
  <span class="n">db_file_path</span><span class="o">:</span> <span class="n">plato</span><span class="sr">/example/domains/</span><span class="n">flowershop</span><span class="o">-</span><span class="n">dbase</span><span class="o">.</span><span class="na">db</span>
  <span class="n">ontology_file_path</span><span class="o">:</span> <span class="n">plato</span><span class="sr">/example/domains/</span><span class="n">flowershop</span><span class="o">-</span><span class="n">rules</span><span class="o">.</span><span class="na">json</span>

<span class="n">ONTOLOGY</span><span class="o">:</span>  <span class="err">#</span> <span class="n">Optional</span>
  <span class="n">informable_slots</span><span class="o">:</span> <span class="o">[</span><span class="n">type</span><span class="o">,</span> <span class="n">price</span><span class="o">,</span> <span class="n">occasion</span><span class="o">]</span>

  <span class="n">requestable_slots</span><span class="o">:</span> <span class="o">[</span><span class="n">price</span><span class="o">,</span> <span class="n">color</span><span class="o">]</span>

  <span class="n">System_requestable_slots</span><span class="o">:</span> <span class="o">[</span><span class="n">type</span><span class="o">,</span> <span class="n">price</span><span class="o">,</span> <span class="n">occasion</span><span class="o">]</span>
</pre></div>


<p>and run the command:</p>
<div class="codehilite"><pre><span></span>plato domain --config create_flowershop_domain.yaml
</pre></div>


<p>If all went well, you should have a <code>flowershop.json</code> and a 
<code>flowershop.db</code> in the <code>plato/example/domains/</code> directory.</p>
<p>If you receive this error:</p>
<div class="codehilite"><pre><span></span>sqlite3.IntegrityError: UNIQUE constraint failed: flowershop.id
</pre></div>


<p>it means that the .db file has already been created.</p>
<p>You can now simply run Plato's dummy components as a sanity check and talk to
your flower shop agent:</p>
<div class="codehilite"><pre><span></span>plato run --config flowershop_text.yaml
</pre></div>


<h3 id="controller">Controller<a class="headerlink" href="#controller" title="Permanent link">&para;</a></h3>
<p>Controllers are objects that orchestrate the conversation between the
agents. The Controller will instantiate the agents, initialize them for each
dialogue, pass input and output appropriately, and keep track of statistics.</p>
<p><img alt="PlatoRDS-Controller" src="../../plato/resources/PlatoRDS-Controller.png" /></p>
<p>Running the command <code>plato run</code> runs Plato's basic controller 
(<code>plato/controller/basic_controller.py</code>). This command receives a value for the <code>--config</code>
argument which points to a Plato application configuration file.</p>
<p>To run a Plato conversational agent, the user must run the following command 
with the appropriate configuration file: </p>
<div class="codehilite"><pre><span></span>plato run --config &lt;FULL PATH TO CONFIG YAML FILE&gt;
</pre></div>


<p>Please refer to <code>plato/example/config/application/</code> for example configuration files which contain 
settings on the environment and the agent(s) to be created as well as their components. 
The examples in <code>plato/example/config/application/</code> could be run directly using just the name of 
the example YAML file: </p>
<div class="codehilite"><pre><span></span>plato run --config &lt;NAME OF A FILE FROM plato/example/config/application/&gt;
</pre></div>


<p>Alternatively a user could write their own config file and run Plato by passing the
full path to their config file to <code>--config</code>:</p>
<div class="codehilite"><pre><span></span>plato run --config &lt;FULL PATH TO CONFIG YAML FILE&gt;
</pre></div>


<p>For the value that is passed to <code>--config</code> plato first checks to see if the value 
is the address of a file on the machine. If it is, the Plato tries to parse that file. 
If it is not, Plato checks to see if the value is a name of a file within the 
<code>plato/example/config/application</code> directory. </p>
<h3 id="agent">Agent<a class="headerlink" href="#agent" title="Permanent link">&para;</a></h3>
<p>Each conversational AI application in Plato could have one or more agents. Each agent 
has a role (system, user, ...) and a set of standard dialog system components
(Figure 1), namely NLU, dialogue manager, dialogue state tracker, policy, 
 NLG, and user simulator. </p>
<p>An agent could have one explicit module for each one of these components. 
Alternatively, some of these components could be combined into one or more modules 
(e.g. joint / end-to-end agents) that can run sequentially or in parallel (Figure 4). 
Plato's components are defined in <code>plato.agent.component</code> and all inherit from 
<code>plato.agent.component.conversational_module</code></p>
<p><img alt="PlatoRDS-AgentComponents" src="plato/resources/PlatoRDS-AgentComponents.png" />
<em>Figure 5. Components of Plato agents</em></p>
<p>Note that any new implementations or custom modules should inherit from 
<code>plato.agent.component.conversational_module</code>.</p>
<p>Each one of these modules could be either rule-based or trained. In the 
following subsections we will describe how to build rule-based and trained 
modules for agents.</p>
<h4 id="rule-based-modules">Rule-based modules<a class="headerlink" href="#rule-based-modules" title="Permanent link">&para;</a></h4>
<p>Plato provides rule-based versions of all components of a Slot-Filling 
conversational agent (slot_filling_nlu, slot_filling_dst, slot_filling_policy,
slot_filling_nlg, and the default version of agenda_based_us). These can be 
used for quick prototyping, baselines, or sanity checks. 
Specifically, all of these components follow rules or patterns conditioned
on the given ontology and sometimes on the given database and should be treated
 as the most basic version of what each component should do.</p>
<h4 id="trained-modules">Trained modules<a class="headerlink" href="#trained-modules" title="Permanent link">&para;</a></h4>
<p>Plato supports training of agents’ components modules in an online 
(during the interaction) or offline (from data) manner, using any deep learning 
framework. Virtually any model can be loaded into Plato as long as Plato’s 
interface Input/Output is respected. For example, if a model is a custom NLU 
module it simply needs to inherit from Plato's NLU abstract class 
(<code>plato.agent.component.nlu</code>) and implement the necessary abstract methods. </p>
<h5 id="plato-internal-experience">Plato internal experience<a class="headerlink" href="#plato-internal-experience" title="Permanent link">&para;</a></h5>
<p>To facilitate online learning, debugging, and evaluation, Plato keeps track of 
its internal experience in a structure called the Dialogue Episode Recorder,
(<code>plato.utilities.dialogue_episode_recorder</code>) 
which contains information about previous dialogue states, actions taken, 
current dialogue states, utterances received and utterances produced, rewards 
received, and a few other structs including a custom field that can be used to 
track anything else that cannot be contained by the aforementioned categories.</p>
<p>At the end of a dialogue or at specified intervals, each conversational agent 
will call the train() function of each of its internal components, passing the 
dialogue experience as training data. Each component then picks the parts it 
needs for training.</p>
<p>To use learning algorithms that are implemented inside Plato, any external 
data, such as DSTC2 data, should be parsed into this Plato experience so that 
they may be loaded and used by the corresponding component under training.</p>
<p>Alternatively, users may parse the data and train their models outside of Plato 
and simply load the trained model when they want to use it for a Plato agent.</p>
<h5 id="parsing-data-with-plato">Parsing data with Plato<a class="headerlink" href="#parsing-data-with-plato" title="Permanent link">&para;</a></h5>
<p>Training online is as easy as flipping the 'train' flags to 'True' in the 
configuration for each component users wish to train. </p>
<p>To train from data, users simply need to load the experience they parsed from 
their dataset. Plato provides example 
parsers for <a href="http://camdial.org/~mh521/dstc/">DSTC2</a> and 
<a href="https://www.microsoft.com/en-us/research/project/metalwoz/">MetaLWOZ</a> datasets. As an 
example of how to use these parsers for offline training in Plato, we will 
use the  DSTC2 dataset, which can be obtained from the 2nd Dialogue State 
Tracking Challenge website:</p>
<div class="codehilite"><pre><span></span>http://camdial.org/~mh521/dstc/downloads/dstc2_traindev.tar.gz
</pre></div>


<p>Once the download is complete, you need to unzip the file. A config file for
parsing this dataset is provided at <code>plato/example/config/parser/Parse_DSTC2.yaml</code>.
You can parse the data that you downloaded by first editing 
the value of <code>data_path</code> in <code>plato/example/config/parser/Parse_DSTC2.yaml</code> to
point to the path to where you downloaded and unzipped the DSTC2 data. Next
you can run the parse script as follows:</p>
<div class="codehilite"><pre><span></span>plato parse --config Parse_DSTC2.yaml
</pre></div>


<p>Alternatively you could write your own config file and pass the absolute address
to that file to the command:</p>
<div class="codehilite"><pre><span></span>plato parse --config &lt;absolute pass to parse config file&gt;
</pre></div>


<p>Running this command will run the parsing script for DSTC2 
(which lives under <code>plato/utilities/parser/parse_dstc2.py</code>) and
will create the training data for dialog state tracker,
NLU, and NLG for both user and system under the <code>data</code> directory at the root 
directory of this repository. Now this parsed data could be used to train
models for different components of Plato.</p>
<h5 id="training-components-of-conversational-agents">Training Components of Conversational Agents<a class="headerlink" href="#training-components-of-conversational-agents" title="Permanent link">&para;</a></h5>
<p>There are multiple ways to train each component of a Plato agent: online (as
the agent interacts with other agents, simulators, or users) or offline. Moreover,
you can use algorithms implemented in Plato or you can use external frameworks
such as TensorFlow, PyTorch, Keras, Ludwig, etc. </p>
<p><a href="https://uber.github.io/ludwig/">Ludwig</a> is an open source deep 
learning framework that allows you to train models without writing any code. 
You only need to parse your data into <code>.csv</code> files, create a ludwig config 
(in YAML), that describes the architecture you want, which features to use from 
the .csv and other parameters and then simply run a command in a terminal.</p>
<p>Ludwig also provides an API, that Plato is compatible with. This allows Plato
to integrate with Ludwig models, i.e. load or save the models, train and query
them. </p>
<h6 id="train-nlu">Train NLU<a class="headerlink" href="#train-nlu" title="Permanent link">&para;</a></h6>
<p>In the previous section, the DSTC2 parser of Plato generated 
some <code>.csv</code> files that can be used to train NLU and NLG. There is one NLU
<code>.csv</code> file for the system (<code>data/DSTC2_NLU_sys.csv</code>) and one for 
the user (<code>data/DSTC2_NLU_usr.csv</code>). These look like this:</p>
<table>
<thead>
<tr>
<th>transcript</th>
<th>intent</th>
<th>iob</th>
</tr>
</thead>
<tbody>
<tr>
<td>expensive restaurant that serves vegetarian food</td>
<td>inform</td>
<td>B-inform-pricerange O O O B-inform-food O</td>
</tr>
<tr>
<td>vegetarian food</td>
<td>inform</td>
<td>B-inform-food O</td>
</tr>
<tr>
<td>asian oriental type of food</td>
<td>inform</td>
<td>B-inform-food I-inform-food O O O</td>
</tr>
<tr>
<td>expensive restaurant asian food</td>
<td>inform</td>
<td>B-inform-pricerange O O</td>
</tr>
</tbody>
</table>
<p>For training a NLU model you need to write a configuration file that looks like this:</p>
<div class="codehilite"><pre><span></span>input_features:
    -
        name: transcript
        type: sequence
        reduce_output: null
        encoder: parallel_cnn

output_features:
    -
        name: intent
        type: set
        reduce_output: null

    -
        name: iob
        type: sequence
        decoder: tagger
        dependencies: [intent]
        reduce_output: null

training:
    epochs: 100
    early_stop: 50
    learning_rate: 0.0025
    dropout: 0.5
    batch_size: 128
</pre></div>


<p>An example of this config file exists in 
<code>plato/example/config/ludwig/ludwig_nlu_train.yaml</code>. The training job could be started
by running:</p>
<div class="codehilite"><pre><span></span>ludwig experiment \
       --model_definition_file plato/example/config/ludwig/ludwig_nlu_train.yaml \
       --data_csv data/DSTC2_NLU_sys.csv \
       --output_directory models/camrest_nlu/sys/
</pre></div>


<p>The next step is to load the model in an application config. In 
<code>plato/example/config/application/CamRest_model_nlu.yaml</code> we provide an
application config that has a model based NLU and the other components are
non-ML-based. By updating the path to the mode (<code>model_path</code>) to the value 
that you provided to the <code>--output_directory</code> argument when you ran ludwig,
you can specify the NLU model that the agent needs to use for NLU: </p>
<div class="codehilite"><pre><span></span>...

MODULE_0:
    package: applications.cambridge_restaurants.camrest_nlu
      class: CamRestNLU
      arguments:
        model_path: &lt;PATH_TO_YOUR_MODEL&gt;/model

...
</pre></div>


<p>and test that the model works:</p>
<div class="codehilite"><pre><span></span>plato run --config CamRest_model_nlu.yaml
</pre></div>


<h6 id="train-dst">Train DST<a class="headerlink" href="#train-dst" title="Permanent link">&para;</a></h6>
<p>The DSTC2 Data Parser generated two <code>.csv</code> files we can use for DST: 
<code>DST_sys.csv</code> and <code>DST_usr.csv</code> which look like this:</p>
<table>
<thead>
<tr>
<th>dst_prev_food</th>
<th>dst_prev_area</th>
<th>dst_prev_pricerange</th>
<th>dst_intent</th>
<th>dst_slot</th>
<th>dst_value</th>
<th>dst_food</th>
<th>dst_area</th>
<th>dst_pricerange</th>
<th>dst_req_slot</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>none</td>
<td>none</td>
<td>inform</td>
<td>food</td>
<td>vegetarian</td>
<td>vegetarian</td>
<td>none</td>
<td>expensive</td>
<td>none</td>
</tr>
<tr>
<td>vegetarian</td>
<td>none</td>
<td>expensive</td>
<td>inform</td>
<td>food</td>
<td>vegetarian</td>
<td>vegetarian</td>
<td>none</td>
<td>expensive</td>
<td>none</td>
</tr>
<tr>
<td>vegetarian</td>
<td>none</td>
<td>expensive</td>
<td>inform</td>
<td>food</td>
<td>asian oriental</td>
<td>asian oriental</td>
<td>none</td>
<td>expensive</td>
<td>none</td>
</tr>
<tr>
<td>asian oriental</td>
<td>none</td>
<td>expensive</td>
<td>inform</td>
<td>food</td>
<td>asian oriental</td>
<td>asian oriental</td>
<td>none</td>
<td>expensive</td>
<td>none</td>
</tr>
<tr>
<td>asian oriental</td>
<td>none</td>
<td>expensive</td>
<td>request</td>
<td>phone</td>
<td>none</td>
<td>asian oriental</td>
<td>none</td>
<td>expensive</td>
<td>phone</td>
</tr>
<tr>
<td>asian oriental</td>
<td>none</td>
<td>expensive</td>
<td>request</td>
<td>area</td>
<td>none</td>
<td>asian oriental</td>
<td>none</td>
<td>expensive</td>
<td>area</td>
</tr>
<tr>
<td>asian oriental</td>
<td>none</td>
<td>expensive</td>
<td>thankyou</td>
<td>none</td>
<td>none</td>
<td>asian oriental</td>
<td>none</td>
<td>expensive</td>
<td>none</td>
</tr>
</tbody>
</table>
<p>Essentially, the parser keeps track of the previous dialogue state, the input
from NLU, and the resulting dialogue state. We can then feed this into Ludwig
to train a Dialogue State Tracker. Here's the ludwig config which can also be
found at <code>example/config/ludwig/ludwig_dst_train.yaml</code>:</p>
<div class="codehilite"><pre><span></span>input_features:
    -
        name: dst_prev_food
        type: category
    -
        name: dst_prev_area
        type: category
    -
        name: dst_prev_pricerange
        type: category
    -
        name: dst_intent
        type: category
    -
        name: dst_slot
        type: category
    -
        name: dst_value
        type: category

output_features:
    -
        name: dst_food
        type: category
    -
        name: dst_area
        type: category
    -
        name: dst_pricerange
        type: category
    -
        name: dst_req_slot
        type: category

training:
  epochs: 100
</pre></div>


<p>We now need to train our model with ludwig:</p>
<div class="codehilite"><pre><span></span>ludwig experiment \
       --model_definition_file plato/example/config/ludwig/ludwig_dst_train.yaml \
       --data_csv data/DST_sys.csv \
       --output_directory models/camrest_dst/sys/
</pre></div>


<p>and run a Plato agent with the model-based DST:</p>
<div class="codehilite"><pre><span></span>plato run --config CamRest_model_dst.yaml
</pre></div>


<p>You can of course experiment with other architectures and training parameters.</p>
<h6 id="train-dialogue-policy">Train Dialogue Policy<a class="headerlink" href="#train-dialogue-policy" title="Permanent link">&para;</a></h6>
<p>So far we have seen how to train components of Plato agents using external 
frameworks (i.e. Ludwig). In this section, we will see how to use Plato's internal
algorithms to train a dialogue policy offline, using supervised learning,
 and online, using reinforcement learning. </p>
<h6 id="supervised-dialogue-policy">Supervised Dialogue Policy<a class="headerlink" href="#supervised-dialogue-policy" title="Permanent link">&para;</a></h6>
<p>Apart from the <code>.csv</code> files, the DSTC2 parser used Plato's dialogue episode
 recorder to also save the parsed dialogues in Plato experience logs here: 
 <code>logs/DSTC2_system</code> and <code>logs/DSTC2_user</code>. These logs contain information about
each dialogue, for example current dialogue state, action taken, next dialogue
state, reward observed, input utterance, success, etc. These logs can be directly
loaded into a conversational agent and can be used to fill the experience pool.</p>
<p>All you need to do then is write a configuration file that loads these logs 
(<code>example/config/CamRest_model_supervised_policy_train.yaml</code>):</p>
<div class="codehilite"><pre><span></span>GENERAL:
  ...

  experience_logs:
    save: False
    load: True
    path: logs/DSTC2_system

  ...

DIALOGUE:
  # Since this configuration file trains a supervised policy from data loaded
  # from the logs, we only really need one dialogue just to trigger the train.
  num_dialogues: 1
  initiative: system
  domain: CamRest

AGENT_0:
  role: system
  max_turns: 15
  train_interval: 1
  train_epochs: 100
  save_interval: 1

  ...

  DM:
    package: plato.agent.component.dialogue_manager.dialogue_manager_generic
    class: DialogueManagerGeneric
    arguments:
      DST:
        package: plato.agent.component.dialogue_state_tracker.slot_filling_dst
        class: SlotFillingDST

      policy:
        package: plato.agent.component.dialogue_policy.deep_learning.supervised_policy
        class: SupervisedPolicy
        arguments:
          train: True
          learning_rate: 0.9
          exploration_rate: 0.995
          discount_factor: 0.95
          learning_decay_rate: 0.95
          exploration_decay_rate: 0.995

          policy_path: models/camrest_policy/sys/sys_supervised_data

  ...
</pre></div>


<p>Note that we only run this agent for one dialogue but train for 100 epochs,
using the experience that is loaded from the logs:</p>
<div class="codehilite"><pre><span></span>plato run --config CamRest_model_supervised_policy_train.yaml
</pre></div>


<p>After training is complete, we can test our supervised policy:</p>
<div class="codehilite"><pre><span></span>plato run --config CamRest_model_supervised_policy_test.yaml
</pre></div>


<h6 id="reinforce-dialogue-policy">Reinforce Dialogue Policy<a class="headerlink" href="#reinforce-dialogue-policy" title="Permanent link">&para;</a></h6>
<p>In the previous section, we saw how to train a Supervised dialogue policy. We 
can now see how we can train a Reinforcement Learning policy, using the
Reinforce algorithm. To do this, we define the relevant class in the configuration
file:</p>
<div class="codehilite"><pre><span></span>...

AGENT_0:
  role: system
  max_turns: 15
  train_interval: 500
  train_epochs: 3
  train_minibatch: 200
  save_interval: 5000

  ...

  DM:
    package: plato.agent.component.dialogue_manager.dialogue_manager_generic
    class: DialogueManagerGeneric
    arguments:
      DST:
        package: plato.agent.component.dialogue_state_tracker.slot_filling_dst
        class: SlotFillingDST

      policy:
        package: plato.agent.component.dialogue_policy.deep_learning.reinforce_policy
        class: ReinforcePolicy
        arguments:
          train: True
          learning_rate: 0.9
          exploration_rate: 0.995
          discount_factor: 0.95
          learning_decay_rate: 0.95
          exploration_decay_rate: 0.995

          policy_path: models/camrest_policy/sys/sys_reinforce

  ...
</pre></div>


<p>Note the learning parameters under <code>AGENT_0</code> and the algorithmic-specific 
parameters under the policy's arguments. We then call plato with this configuration:</p>
<div class="codehilite"><pre><span></span>plato run --config CamRest_model_reinforce_policy_train.yaml
</pre></div>


<p>and test the trained policy model:</p>
<div class="codehilite"><pre><span></span>plato run --config CamRest_model_reinforce_policy_test.yaml
</pre></div>


<p><strong>Note</strong> that other components can also be trained online, either using Ludwig's
API or by implementing the learning algorithms in Plato. </p>
<p><strong>Note</strong> also that log files can be loaded and used as experience pool for any
component and learning algorithm. However, you may need to implement your own 
learning algorithms for some Plato components.</p>
<h6 id="train-nlg">Train NLG<a class="headerlink" href="#train-nlg" title="Permanent link">&para;</a></h6>
<p>To train an NLG module you need to write a 
configuration file that looks like this (e.g. 
<code>example/config/application/CamRest_model_nlg.yaml</code>):</p>
<div class="codehilite"><pre><span></span>---

input_features:
    -
        name: nlg_input
        type: sequence
        encoder: rnn
        cell_type: lstm

output_features:
    -
        name: nlg_output
        type: sequence
        decoder: generator
        cell_type: lstm

training:
    epochs: 20
    learning_rate: 0.001
    dropout: 0.2
</pre></div>


<p>and train your model:</p>
<div class="codehilite"><pre><span></span>ludwig experiment \
       --model_definition_file plato/example/config/ludwig/ludwig_nlg_train.yaml \
       --data_csv data/DSTC2_NLG_sys.csv \
       --output_directory models/camrest_nlg/sys/
</pre></div>


<p>The next step is to load the model in Plato. Go to the 
<code>CamRest_model_nlg.yaml</code> configuration file and update the path if 
necessary:</p>
<div class="codehilite"><pre><span></span>...

  NLG:
    package: applications.cambridge_restaurants.camrest_nlg
    class: CamRestNLG
    arguments:
      model_path: models/camrest_nlg/sys/experiment_run/model
...
</pre></div>


<p>and test that the model works:</p>
<div class="codehilite"><pre><span></span>plato run --config CamRest_model_nlg.yaml
</pre></div>


<p>Remember that Ludwig will create a new <em>experiment_run_i</em> directory each time 
it is called, so please make sure you keep the correct path in Plato's config 
up to date.</p>
<p>Note that Ludwig also offers a method to train your model online, so in 
practice you need to write very little code to build, train, and evaluate a
new deep learning component in Plato. </p>
<h5 id="train-an-end-to-end-conversational-agent-based-on-seq2seq">Train an end-to-end conversational agent based on Seq2Seq<a class="headerlink" href="#train-an-end-to-end-conversational-agent-based-on-seq2seq" title="Permanent link">&para;</a></h5>
<p>For this example, we will use the MetalWoz dataset that you can download from 
<a href="https://www.microsoft.com/en-us/research/project/metalwoz/">here</a>.</p>
<p>Plato supports jointly trained models through Generic Agents. Here we will see
the steps needed to create a simple seq2seq conversational agent from scratch.
Using MetalWOZ as an example, we need to do the following:</p>
<h6 id="1-write-a-metalwoz-data-parser-that-reads-the-data-and-procudes-csv-files">1. Write a MetalWOZ data parser that reads the data and procudes CSV files<a class="headerlink" href="#1-write-a-metalwoz-data-parser-that-reads-the-data-and-procudes-csv-files" title="Permanent link">&para;</a></h6>
<p>As we are only training a simple seq2seq model (text to text), we need our 
parser to extract user and system utterances. These will be saved in .csv files
that will be used by Ludwig in step 4.</p>
<p>For a simple implementation of a MetalWOZ parser, see 
<code>utilities/parser/Parse_MetalWOZ.py</code></p>
<p>Please note that this parser will only parse one single file (one domain). You
can easily modify it, however, to fit your needs. Here is a sample of the 
output produced by the parser for the pizza ordering domain:</p>
<table>
<thead>
<tr>
<th>user</th>
<th>system</th>
</tr>
</thead>
<tbody>
<tr>
<td>hi</td>
<td>Hello how may I help you?</td>
</tr>
<tr>
<td>I need placing an order for a pizza need help</td>
<td>Certainly, what would you like to add to your order?</td>
</tr>
<tr>
<td>I want a pizza with mushroom, pepperoni, and bacon toppings</td>
<td>Unfortunately, this location is out of the bacon topping you requested. Would there be a different topping you'd like to replace it with?</td>
</tr>
<tr>
<td>How about pineapple</td>
<td>That topping is available. I've added a pizza with mushroom, pepperoni, and pineapple to your order. What size would you like?</td>
</tr>
<tr>
<td>Medium</td>
<td>Alright, updated. Would you like to add more to your order?</td>
</tr>
<tr>
<td>That's all, thanks</td>
<td>Alright, your total is 14.99. Your pizza will be ready for pickup in approx. 20 mins.</td>
</tr>
</tbody>
</table>
<p>Note the first user utterance does not actually exist in the data. However,
we need something to prompt the model to produce the system's greeting - we 
could have used an empty sentence, or any other greeting (or a combination of 
these).</p>
<h6 id="2-write-a-config-for-plato-parse">2. Write a config for plato parse<a class="headerlink" href="#2-write-a-config-for-plato-parse" title="Permanent link">&para;</a></h6>
<p>You can then run plato parse as follows:</p>
<div class="codehilite"><pre><span></span>plato parse --config Parse_MetalWOZ.yaml
</pre></div>


<h6 id="3-train-an-end-to-end-model">3. Train an end-to-end model<a class="headerlink" href="#3-train-an-end-to-end-model" title="Permanent link">&para;</a></h6>
<p>To get started we can train a very simple model using Ludwig (feel free to use
your favourite deep learning framework here):</p>
<div class="codehilite"><pre><span></span>input_features:
    -
        name: user
        type: text
        level: word
        encoder: rnn
        cell_type: lstm
        reduce_output: null

output_features:
    -
        name: system
        type: text
        level: word
        decoder: generator
        cell_type: lstm
        attention: bahdanau

training:
  epochs: 100
</pre></div>


<p>You can modify this config to reflect the architecture of your choice and train
using Ludwig:</p>
<div class="codehilite"><pre><span></span>ludwig train \
       --data_csv data/metalwoz.csv \
       --model_definition_file plato/example/config/ludwig/metalWOZ_seq2seq_ludwig.yaml \
       --output_directory &quot;models/joint_models/&quot;
</pre></div>


<h6 id="4-write-a-class-inheriting-from-conversational-module-that-loads-and-queries-the-model">4. Write a class inheriting from Conversational Module that loads and queries the model<a class="headerlink" href="#4-write-a-class-inheriting-from-conversational-module-that-loads-and-queries-the-model" title="Permanent link">&para;</a></h6>
<p>This class simply needs to handle loading of the model, querying it 
appropriately and formatting its output appropriately. In our case, we need to 
wrap the input text into a pandas dataframe, grab the predicted tokens from 
the output and join them in a string that will be returned. See the class here:
<code>plato.agent.component.joint_model.metal_woz_seq2seq.py</code></p>
<h6 id="5-write-a-plato-generic-yaml-config-and-run-your-agent">5. Write a Plato generic yaml config and run your agent!<a class="headerlink" href="#5-write-a-plato-generic-yaml-config-and-run-your-agent" title="Permanent link">&para;</a></h6>
<p>See <code>plato/example/config/application/metalwoz_generic.yaml</code> for an example generic 
configuration file that interacts with the seq2seq agent over text. You can try
it out as follows:</p>
<div class="codehilite"><pre><span></span>plato run --config metalwoz_text.yaml
</pre></div>


<p><strong>Remember</strong> to update the path to your trained model if necessary! The default
path assumes you run the ludwig train command from Plato's root directory.</p>
<h4 id="training-multiple-conversational-agents-simultaneously">Training Multiple Conversational Agents Simultaneously<a class="headerlink" href="#training-multiple-conversational-agents-simultaneously" title="Permanent link">&para;</a></h4>
<p>One of Plato's main features allows two agents to interact with each other. 
Each agent can have a different role (for instance, system and user), different 
objectives, and receive different reward signals. If the agents are 
cooperating, some of these can be shared (e.g., what constitutes a successful 
dialogue). </p>
<p>To run multiple Plato agents on the Cambridge Restaurants domain, we run the 
following commands to train the agents’ dialogue policies and test them:</p>
<ul>
<li>
<p>Training phase: 2 policies (1 for each agent) are trained. 
These policies are trained using the <a href="http://www.cs.cmu.edu/~mmv/papers/01ijcai-mike.pdf">WoLF</a>
algorithm:</p>
<p><code>plato run --config MultiAgent_train.yaml</code></p>
</li>
<li>
<p>Testing phase: uses the policy trained in the training phase to create
dialogs between two agents:</p>
<p><code>plato run --config MultiAgent_test.yaml</code></p>
</li>
</ul>
<p>While the basic controller currently allows two agent interaction, it is fairly
straightforward to extend it to multiple agents (e.g. with a blackboard architecture,
where each agent broadcasts its output to other agents). This can support scenarios
such as smart homes, where every device is an agent, multi-user interactions with
various roles, and more.</p>
<h4 id="user-simulators">User Simulators<a class="headerlink" href="#user-simulators" title="Permanent link">&para;</a></h4>
<p>Plato provides implementations for two kinds of user simulators. One is the very
well known Agenda-Based User Simulator, and the other is a simulator that
attempts to mimic user behaviour observed in data. However, we encourage 
researchers to simply train two conversational agents with Plato (one being a 
'system' and one being a 'user') instead of using simulated users, when possible.</p>
<h5 id="agenda-based-user-simulator">Agenda-Based User Simulator<a class="headerlink" href="#agenda-based-user-simulator" title="Permanent link">&para;</a></h5>
<p>The Agenda-Based User Simulator was proposed by Schatzmann and is explained
in detail in this 
<a href="https://www.semanticscholar.org/paper/Statistical-user-simulation-with-a-hidden-agenda-Schatzmann-Thomson/fdde1f5ee1734e562298d6d4ca6893921276f0d2">paper</a>. 
Conceptually, the simulator maintains an "agenda"
of things to say, which is usually implemented as a stack. When the simulator 
receives input, it consults its policy (or its set of rules) to see what content
to push into the agenda, as a response to the input. After some housekeeping
(e.g. removing duplicates or content that is no longer valid), the simulator
will pop one or more items off the agenda that will be used to formulate its 
response.</p>
<p>The Agenda-Based User Simulator also has an error simulation module, that can
simulate speech recognition / language understanding errors. Based on some
probabilities, it will distort the output dialogue acts of the simulator - the
intent, slot, or value (different probability for each). Here is an example 
of the full list of parameters that this simulator receives:</p>
<div class="codehilite"><pre><span></span><span class="n">patience</span><span class="o">:</span> <span class="mi">5</span>                         <span class="err">#</span> <span class="n">Stop</span> <span class="n">after</span> <span class="o">&lt;</span><span class="n">patience</span><span class="o">&gt;</span> <span class="n">consecutive</span> <span class="n">identical</span> <span class="n">inputs</span> <span class="n">received</span>
<span class="n">pop_distribution</span><span class="o">:</span> <span class="o">[</span><span class="mf">0.8</span><span class="o">,</span> <span class="mf">0.15</span><span class="o">,</span> <span class="mf">0.05</span><span class="o">]</span> <span class="err">#</span> <span class="n">pop</span> <span class="mi">1</span> <span class="n">act</span> <span class="k">with</span> <span class="mf">0.8</span> <span class="n">probability</span><span class="o">,</span> <span class="mi">2</span> <span class="n">acts</span> <span class="k">with</span> <span class="mf">0.15</span><span class="o">,</span> <span class="n">etc</span><span class="o">.</span>
<span class="n">slot_confuse_prob</span><span class="o">:</span> <span class="mf">0.05</span>             <span class="err">#</span> <span class="n">probability</span> <span class="n">by</span> <span class="n">which</span> <span class="n">the</span> <span class="n">error</span> <span class="n">model</span> <span class="n">will</span> <span class="n">alter</span> <span class="n">the</span> <span class="n">output</span> <span class="n">dact</span> <span class="n">slot</span> 
<span class="n">op_confuse_prob</span><span class="o">:</span> <span class="mf">0.01</span>               <span class="err">#</span> <span class="n">probability</span> <span class="n">by</span> <span class="n">which</span> <span class="n">the</span> <span class="n">error</span> <span class="n">model</span> <span class="n">will</span> <span class="n">alter</span> <span class="n">the</span> <span class="n">output</span> <span class="n">dact</span> <span class="n">operator</span>
<span class="n">value_confuse_prob</span><span class="o">:</span> <span class="mf">0.01</span>            <span class="err">#</span> <span class="n">probability</span> <span class="n">by</span> <span class="n">which</span> <span class="n">the</span> <span class="n">error</span> <span class="n">model</span> <span class="n">will</span> <span class="n">alter</span> <span class="n">the</span> <span class="n">output</span> <span class="n">dact</span> <span class="n">value</span>
<span class="n">nlu</span><span class="o">:</span> <span class="n">slot_filling</span>                   <span class="err">#</span> <span class="n">type</span> <span class="n">of</span> <span class="n">NLU</span> <span class="n">the</span> <span class="n">simulator</span> <span class="n">will</span> <span class="n">use</span>
<span class="n">nlg</span><span class="o">:</span> <span class="n">slot_filling</span>                   <span class="err">#</span> <span class="n">type</span> <span class="n">of</span> <span class="n">NLG</span> <span class="n">the</span> <span class="n">simulator</span> <span class="n">will</span> <span class="n">use</span>
</pre></div>


<h5 id="dialogue-act-to-language-user-simulator">Dialogue Act to Language User Simulator<a class="headerlink" href="#dialogue-act-to-language-user-simulator" title="Permanent link">&para;</a></h5>
<p>This simulator was designed to be a simple policy-based simulator, that can 
operate at the dialogue act level or at the utterance level. To demonstrate
how it works, the DSTC2 parser created a policy file for this simulator: 
<code>user_policy_reactive.pkl</code> (reactive because it reacts to system dialogue
acts instead of user simulator state). This is actually a simple dictionary of:</p>
<div class="codehilite"><pre><span></span>System Dial. Act 1 --&gt;  {&#39;dacts&#39;: {User Dial. Act 1: probability}
                                  {User Dial. Act 2: probability}
                                  ...

                         &#39;responses&#39;: {User utterance 1: probability}
                                      {User utterance 2: probability}
                                      ...

System Dial. Act 2 --&gt; ...
</pre></div>


<p>The key represents the input dialogue act (e.g. coming from the <code>system</code> 
conversational agent). The value of each key is a dictionary of two elements,
representing probability distributions over dialogue acts or utterance templates 
that the simulator will sample from.</p>
<p>To see an example, you can run the following configuration:</p>
<div class="codehilite"><pre><span></span>plato run --config CamRest_dtl_simulator.yaml
</pre></div>


<h4 id="create-a-new-module">Create a new module<a class="headerlink" href="#create-a-new-module" title="Permanent link">&para;</a></h4>
<p>There are two ways to create a new module depending on its function. If a 
module, for example, implements a new way of performing NLU or dialogue policy, 
then you should write a class that inherits from the corresponding abstract class.</p>
<p>If, however, a module does not fit one of the single agent basic components, 
for example, it performs Named Entity Recognition or predicts dialogue acts 
from text, then you must write a class that inherits from the 
<code>conversational_module</code> directly. You can then load the module via a
generic agent by providing the appropriate package path, class name, and 
arguments in the configuration.</p>
<div class="codehilite"><pre><span></span>...
MODULE_i:
    package: my_package.my_module
    Class: MyModule
    arguments:
      model_path: models/my_module/parameters/
      ...
...
</pre></div>


<p><strong>Be careful!</strong> You are responsible for guaranteeing that the I/O of this 
module can be processed and consumed appropriately by modules before and after, 
as provided in your generic configuration file.</p>
<p>Plato also supports (logically) parallel execution of modules. To enable that you need to
have the following structure in your config:</p>
<div class="codehilite"><pre><span></span>...
MODULE_i:
    parallel_modules: 5

    PARALLEL_MODULE_0:
        package: my_package.my_module
        Class: MyModule
        arguments:
          model_path: models/myModule/parameters/
          ...

    PARALLEL_MODULE_1:
        package: my_package.my_module
        Class: MyModule
        arguments:
          model_path: models/my_module/parameters/
          ...

    ...
...
</pre></div>


<p><strong>Be careful!</strong> Outputs from the modules executed in parallel will be packed
into a list. The next module (e.g. <code>MODULE_i+1</code>) will need to be able
to handle this kind of input. <strong>The provided Plato modules are not designed to 
handle this, you will need to write a custom module to process input from
multiple sources.</strong></p>
<h5 id="create-new-states-actions-learning-algorithms-and-more">Create new States, Actions, Learning Algorithms, and more<a class="headerlink" href="#create-new-states-actions-learning-algorithms-and-more" title="Permanent link">&para;</a></h5>
<p>Plato is designed to be extensible, so feel free to create your own Dialogue
States, Actions, Reward Functions, Algorithms, or any other component to suit
your specific needs. You only need to inherit from the corresponding class to
make sure your implementation is compatible with Plato. </p>
<h3 id="graphical-user-interface">Graphical User Interface<a class="headerlink" href="#graphical-user-interface" title="Permanent link">&para;</a></h3>
<p>Plato uses <a href="https://pysimplegui.readthedocs.io/en/latest/">PySimpleGUI</a> to
handle graphical user interfaces. An example GUI for Plato is implemented at
 <code>platosgui_controller</code> and you can try it out using the following command:</p>
<div class="codehilite"><pre><span></span>plato gui --config CamRest_GUI_speech.yaml
</pre></div>


<h2 id="upcoming-tutorials">Upcoming Tutorials<a class="headerlink" href="#upcoming-tutorials" title="Permanent link">&para;</a></h2>
<ol>
<li>Using pre-trained models (BERT, GPT, etc.) in Plato </li>
<li>Multi-domain Conversational Agents</li>
<li>Multi-lingual Conversational Agents</li>
</ol>
<h2 id="upcoming-features">Upcoming Features<a class="headerlink" href="#upcoming-features" title="Permanent link">&para;</a></h2>
<ol>
<li>Principled logging and printing</li>
<li>More dataset parsers</li>
<li>More options for multi-agent controllers</li>
<li>Bayesian Optimisation in Plato</li>
</ol>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        

<!-- Application footer -->
<footer class="md-footer">

    <!-- Link to previous and/or next page -->
    
    <div class="md-footer-nav">
        <nav class="md-footer-nav__inner md-grid">

            <!-- Link to previous page -->
            
            <a class="md-flex md-footer-nav__link md-footer-nav__link--prev"
               href="../about/"
               rel="prev"
               title="About">
                <div class="md-flex__cell md-flex__cell--shrink">
                    <i class="md-icon md-icon--arrow-back
                    md-footer-nav__button"></i>
                </div>
                <div class="md-flex__cell md-flex__cell--stretch
                  md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                About
              </span>
                </div>
            </a>
            

            <!-- Link to next page -->
            
        </nav>
    </div>
    

    <!-- Further information -->
    <div class="md-footer-meta md-typeset">
        <div class="md-footer-meta__inner md-grid">

            <!-- Copyright and theme information -->
            <div class="md-footer-copyright">
                <div class="footer-logo-smallpad"></div>
                
                <div class="md-footer-copyright__highlight">
                    Copyright &copy; 2019 Uber Technologies Inc.
                </div>
                
                Website by <a href="http://w4nderlu.st">w4nderlust</a> powered by
                <a href="https://www.mkdocs.org">MkDocs</a>,
                <a href="https://squidfunk.github.io/mkdocs-material/">Material for MkDocs</a>,
                <a href="http://www.styleshout.com/">styleshout</a>.
                Uses the <a href="http://www.ff3300.com/works/sistema-museale-ugento">Messapia</a> font by <a href="http://ff3300.com/">FF3300</a>.
            </div>

            <!-- Social links -->
            
            
            
        </div>
    </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.245445c6.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
    
  </body>
</html>